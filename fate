#!python
import sys
from fatecore import session
from fatecore import selectors, operators
from fatecore.selection import Selection
import curses
from curses.textpad import Textbox
import re
import logging
import os
import signal

# Intercept ctrl-c, ctrl-\ and ctrl-z
def signal_handler(signal, frame):
    pass
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGQUIT, signal_handler)
signal.signal(signal.SIGTSTP, signal_handler)

# Lower the annoying delay for the escape character
# VIM also uses 25 ms
os.environ['ESCDELAY'] = '25'


class UserInterface:
    def __init__(self):
        if len(sys.argv) > 1:
            self.session = session.Session(sys.argv[1])
        else:
            self.session = session.Session()
        self.session.read()
        self.session.searchPattern = ""

    def main(self, stdscr):
        # Initialize color pairs from the terminal color palette
        curses.use_default_colors()
        for i in range(0, curses.COLORS):
            curses.init_pair(i, i, -1);
        curses.init_pair(9, -1, 0);

        # Create curses windows
        self.stdscr = stdscr
        curses.curs_set(0)
        y, x = self.stdscr.getmaxyx()
        self.text_win = curses.newwin(y - 1, x, 0, 0)
        self.status_win = curses.newwin(1, x, y - 1, 0)
        self.stdscr.refresh()

        # Enter the main loop
        while 1:
            self.mode = self.session.selection_mode
            self.draw_text()
            self.selection_mode()

    def selection_mode(self):
        key = chr(self.stdscr.getch())
        s = self.session

        if key == 'Q':
            if not self.session.saved:
                self.set_status("Unsaved changes! Really quit? (y/n)")
                while 1:
                    c = chr(self.stdscr.getch())
                    if c == 'y':
                        exit()
                    if c == 'n':
                        break
            else:
                exit()

        if key == 'j':
            s.apply(selectors.next_line)
        elif key == 'k':
            s.apply(selectors.previous_line)
        elif key == 'J':
            s.apply(selectors.next_full_line)
        elif key == 'K':
            s.apply(selectors.previous_full_line)
        elif key == 'l':
            s.apply(selectors.next_char)
        elif key == 'h':
            s.apply(selectors.previous_char)
        elif key == 'w':
            s.apply(selectors.next_word)
        elif key == 'b':
            s.apply(selectors.previous_word)
        elif key == '}':
            s.apply(selectors.next_paragraph)
        elif key == '{':
            s.apply(selectors.previous_paragraph)
        elif key == 'm':
            s.apply(selectors.join)
        elif ord(key) == 27:
            if s.selection_mode != session.select_mode:
                s.selection_mode = session.select_mode
            else:
                s.apply(selectors.empty)
        elif key == 'z':
            s.apply(selectors.complement)
        elif key == 'f':
            char = chr(self.stdscr.getch())
            s.apply(selectors.pattern_interval_selector(re.escape(char)))
        elif key == '/':
            s.searchPattern = self.prompt('/')
            s.apply(selectors.global_pattern_selector(s.searchPattern))
        elif key == '*':
            s.searchPattern = re.escape(s.content(s.selection)[-1])
            s.apply(selectors.global_pattern_selector(s.searchPattern))
        elif key == 'n':
            if s.searchPattern:
                s.apply(selectors.global_pattern_selector(s.searchPattern))
        elif key == 'N':
            if s.searchPattern:
                s.apply(selectors.global_pattern_selector(s.searchPattern, reverse=True))
        elif key == 'i':
            self.insert_mode(operators.change_before)
        elif key == 'a':
            self.insert_mode(operators.change_after)
        elif key == 's':
            self.insert_mode(operators.change_around)
        elif key == 'c':
            self.insert_mode(operators.change_in_place)
        elif key == 'x':
            operation = operators.delete(s.selection)
            s.selection = s.apply(operation)
        elif key == 'o':
            s.selection = operators.open_line(s.selection)
            self.insert_mode(operators.change_after)
        elif key == 'y':
            s.copy()
        elif key == 'p':
            s.paste()
        elif key == 'P':
            s.paste(before=True)
        elif key == 'r':
            s.selection_mode = session.reduce_mode
        elif key == 'e':
            s.selection_mode = session.extend_mode
        elif key == 'u':
            s.undo()
        elif key == 'U':
            s.redo()
        elif key == 'W':
            s.write()
        elif key == ':':
            scope = vars(s)
            for name in vars(session.Session).keys():
                scope.update({name: eval('s.' + name)})
            scope.update({'self': s})
            command = self.prompt(':')
            try:
                result = eval(command, scope)
                if result != None:
                    self.set_status(str(result))
                    self.stdscr.getch()
            except Exception as e:
                self.set_status(command + ' : ' + str(e))
                self.stdscr.getch()
            self.status_win.clear()

    def insert_mode(self, operator_constructor):
        self.mode = 'OPERATION'
        insertions = ''
        deletions = 0
        while 1:
            pending_operator = operator_constructor(insertions, deletions)
            self.draw_text(pending_operator)
            key = self.stdscr.getch()
            if key == 27:
                self.session.apply(pending_operator)
                break;
            elif key == curses.KEY_BACKSPACE:
                if insertions:
                    insertions = insertions[:-1]
                else:
                    deletions += 1
            elif key == curses.KEY_DC:
                # Do something useful here?
                pass
            else:
                insertions += chr(key)

    def draw_operation_interval(self, interval, content):
        content = content.replace('\n', '↵\n') or 'ε'
        self.text_win.addstr(content, curses.A_BOLD | curses.A_REVERSE)

    def draw_selection_interval(self, interval):
        beg, end = interval
        if end - beg > 0:
            self.draw_interval(interval, selected=True)
        else:
            self.text_win.addstr('ε', curses.A_REVERSE)

    def draw_interval(self, interval, selected=False):
        beg, end = interval
        for position in range(beg, end):
            # Print next character of the interval
            attribute = curses.A_NORMAL
            char = self.session.text[position]

            # Apply attribute when char is selected
            if selected:
                attribute |= curses.A_REVERSE
                # Display newline character explicitly when selected
                if char == '\n':
                    char = '↵\n'

            # Apply attribute if char is labeled
            if position in self.session.labeling:
                for i, label in enumerate(['string', 'number', 'keyword', 'comment']):
                    if self.session.labeling[position] == label:
                        attribute |= curses.color_pair(i + 1)

            self.text_win.addstr(char, attribute)

    def draw_text(self, pending_operator=None):
        self.text_win.move(0, 0)

        # Find a suitable starting position
        y, x = self.text_win.getmaxyx()
        selection = self.session.selection
        position = move_n_wrapped_lines_up(self.session.text, x, max(0, selection[0][0]), int(y / 2))

        try:
            # Find index of first selected interval that has to be drawn
            for index in range(len(selection)):
                if selection[index][1] > position:
                    break

            # Alternate between selected intervals and regular intervals
            while 1:
                if index < len(selection):
                    interval = selection[index]  # interval is the next selected interval to be drawn

                    if interval[0] <= position:
                        # Print selected interval
                        if pending_operator:
                            self.draw_operation_interval(interval, pending_operator(self.session, preview=True).new_content[index])
                        else:
                            self.draw_selection_interval(interval)
                        position = interval[1]
                        index += 1
                    else:
                        # Print regular interval
                        self.draw_interval((position, interval[0]))
                        position = interval[0]
                else:
                    self.draw_interval((position, len(self.session.text)))
                    position = len(self.session.text)

                if position >= len(self.session.text):
                    break

            self.text_win.addstr('EOF\n', curses.A_BOLD)
        except curses.error:
            # End of screen reached
            pass

        try:
            self.set_status(self.session.filename +
                           ("*" if not self.session.saved else "") + " | " + str(self.session.filetype)
                            + " | " + self.mode + " | " + str(self.session.selection))
        except curses.error:
            # End of screen reached
            pass

        self.text_win.clrtobot()
        self.text_win.refresh()

    def set_status(self, string):
        self.status_win.bkgd(' ', curses.color_pair(9))
        try:
            self.status_win.addstr(0, 0, string, curses.color_pair(9))
        except:
            pass
        self.status_win.clrtobot()
        self.status_win.refresh()

    def prompt(self, prompt_string='>'):
        self.status_win.clear()
        y, x = self.stdscr.getmaxyx()
        self.status_win.addstr(0, 0, prompt_string)
        self.status_win.refresh()
        l = len(prompt_string)
        text_box_win = curses.newwin(1, x - l, y - 1, l)
        text_box_win.bkgd(' ', curses.color_pair(9))
        text_box = Textbox(text_box_win)
        text_box.edit()
        return text_box.gather()[:-1]


def move_n_wrapped_lines_up(text, wrap, start, n):
    position = text.rfind('\n', 0, start)
    if position == -1:
        return 0
    while 1:
        next = text.rfind('\n', 0, position - 1)
        if next == -1:
            return 0
        n -= int((position - next) / wrap) + 1
        if n <= 0:
            return position + 1
        position = next

ui = UserInterface()
curses.wrapper(ui.main)
