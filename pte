#!python
import sys
from protexted import session
from protexted import selectors, operators
from protexted.selection import Selection
import curses
from curses.textpad import Textbox
import re
import logging
import os
import signal

# Intercept ctrl-c, ctrl-\ and ctrl-z
def signal_handler(signal, frame):
    pass
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGQUIT, signal_handler)
signal.signal(signal.SIGTSTP, signal_handler)

# Lower the annoying delay for the escape character
# VIM also uses 25 ms
os.environ['ESCDELAY'] = '25'

class UserInterface:
    def __init__(self):
        if len(sys.argv) > 1:
            self.session = session.Session(sys.argv[1])
        else:
            self.session = session.Session()
        self.session.read()
        self.session.searchPattern = ""

    def main(self, stdscr):
        # Initialize color pairs from the terminal color palette
        curses.use_default_colors()
        for i in range(0, curses.COLORS):
            curses.init_pair(i, i, -1);
        curses.init_pair(9, -1, 0);

        # Create curses windows
        self.stdscr = stdscr
        curses.curs_set(0)
        y, x = self.stdscr.getmaxyx()
        self.text_win = curses.newwin(y - 1, x, 0, 0)
        self.status_win = curses.newwin(1, x, y - 1, 0)
        self.stdscr.refresh()

        # Enter the main loop
        while 1:
            self.mode = self.session.selection_mode
            self.draw_text()
            self.selection_mode()

    def selection_mode(self):
        key = self.stdscr.getch()
        s = self.session

        if key == ord('Q'):
            exit()

        # Allow quantor to be set before a doing a selection
        if key == ord('A'):
            s.forall = True
            key = self.stdscr.getch()

        if key == ord('j'):
            s.select(selectors.next_line)
        elif key == ord('k'):
            s.select(selectors.previous_line)
        elif key == ord('J'):
            s.select(selectors.next_full_line)
        elif key == ord('K'):
            s.select(selectors.previous_full_line)
        elif key == ord('l'):
            s.select(selectors.next_char)
        elif key == ord('h'):
            s.select(selectors.previous_char)
        elif key == ord('w'):
            s.select(selectors.next_word)
        elif key == ord('b'):
            s.select(selectors.previous_word)
        elif key == ord('}'):
            s.select(selectors.next_paragraph)
        elif key == ord('{'):
            s.select(selectors.previous_paragraph)
        elif key == ord('m'):
            s.select(selectors.join)
        elif key == 27:
            if s.selection_mode != session.select_mode:
                s.selection_mode = session.select_mode
            else:
                s.select(selectors.empty)
        elif key == ord('z'):
            s.select(selectors.complement)
        elif key == ord('f'):
            char = chr(self.stdscr.getch())
            s.select(selectors.pattern_interval_selector(re.escape(char)))
        elif key == ord('/'):
            s.searchPattern = self.prompt('/')
            s.select(selectors.pattern_selector(s.searchPattern))
        elif key == ord('*'):
            s.searchPattern = re.escape(s.content(s.selection)[-1])
            s.select(selectors.pattern_selector(s.searchPattern))
        elif key == ord('n'):
            if s.searchPattern:
                s.select(selectors.pattern_selector(s.searchPattern))
        elif key == ord('N'):
            if s.searchPattern:
                s.select(selectors.pattern_selector(s.searchPattern, reverse=True))
        elif key == ord('i'):
            self.insert_mode(operators.change_before)
        elif key == ord('a'):
            self.insert_mode(operators.change_after)
        elif key == ord('s'):
            self.insert_mode(operators.change_around)
        elif key == ord('c'):
            self.insert_mode(operators.change_in_place)
        elif key == ord('x'):
            operation = operators.delete(s.selection, s)
            s.apply(operation)
        elif key == ord('y'):
            s.copy()
        elif key == ord('p'):
            s.paste()
        elif key == ord('P'):
            s.paste(before=True)
        elif key == ord('r'):
            s.selection_mode = session.reduce_mode
        elif key == ord('e'):
            s.selection_mode = session.extend_mode
        elif key == ord('u'):
            s.undo()
        elif key == ord('U'):
            s.redo()
        elif key == ord('W'):
            s.write()
        elif key == ord(':'):
            scope = vars(s)
            for name in vars(session.Session).keys():
                scope.update({name: eval('s.' + name)})
            scope.update({'self': eval('s')})
            command = self.prompt(':')
            try:
                result = eval(command, scope)
                if result != None:
                    self.set_status(str(result))
                    self.stdscr.getch()
            except Exception as e:
                self.set_status(command + ' : ' + str(e))
                self.stdscr.getch()
            self.status_win.clear()

        # Reset quantors
        s.forall = False

    def insert_mode(self, operator):
        self.mode = 'OPERATION'
        insertions = ''
        deletions = 0
        while 1:
            operation = operator(self.session, self.session.selection, insertions, deletions)
            self.draw_text(operation)
            key = self.stdscr.getch()
            if key == 27:
                self.session.apply(operation)
                self.session.selection_mode = session.select_mode
                break;
            elif key == curses.KEY_BACKSPACE:
                if insertions:
                    insertions = insertions[:-1]
                else:
                    deletions += 1
            elif key == curses.KEY_DC:
                # Do something useful here?
                pass
            else:
                insertions += chr(key)

    def draw_operation_interval(self, interval, content):
        if content == '':
            self.text_win.addstr('ε', curses.A_BOLD | curses.A_REVERSE)
        else:
            self.text_win.addstr(content.replace('\n', '↵\n'), curses.A_BOLD | curses.A_REVERSE)

    def draw_selection_interval(self, interval):
        beg, end = interval
        if end - beg > 0:
            self.draw_interval(interval, selected=True)
        else:
            self.text_win.addstr('ε', curses.A_REVERSE)

    def draw_interval(self, interval, selected=False):
        beg, end = interval
        for position in range(beg, end):
            # Print next character of the interval
            attribute = curses.A_NORMAL
            char = self.session.text[position]

            # Apply attribute when char is selected
            if selected:
                attribute |= curses.A_REVERSE
                # Display newline character explicitly when selected
                if char == '\n':
                    char = '↵\n'

            # Apply attribute if char is labeled
            if position in self.session.labeling:
                for i, label in enumerate(['string', 'number', 'keyword', 'comment']):
                    if self.session.labeling[position] == label:
                        attribute |= curses.color_pair(i + 1)

            self.text_win.addstr(char, attribute)

    def draw_text(self, pending_operation=None):
        self.text_win.move(0, 0)

        # Find a suitable starting position
        y, x = self.text_win.getmaxyx()
        selection = self.session.selection
        position = move_n_wrapped_lines_up(self.session.text, x, max(0, selection[0][0]), int(y / 2))

        try:
            # Find index of first selected interval that has to be drawn
            for index in range(len(selection)):
                if selection[index][1] > position:
                    break

            # Alternate between selected intervals and regular intervals
            while 1:
                if index < len(selection):
                    interval = selection[index]  # interval is the next selected interval to be drawn

                    if interval[0] <= position:
                        # Print selected interval
                        if pending_operation:
                            self.draw_operation_interval(interval, pending_operation.new_content[index])
                        else:
                            self.draw_selection_interval(interval)
                        position = interval[1]
                        index += 1
                    else:
                        # Print regular interval
                        self.draw_interval((position, interval[0]))
                        position = interval[0]
                else:
                    self.draw_interval((position, len(self.session.text)))
                    position = len(self.session.text)

                if position >= len(self.session.text):
                    break

            self.text_win.addstr('EOF\n', curses.A_BOLD)
        except curses.error:
            # End of screen reached
            pass

        try:
            self.set_status(self.session.filename + " | " + str(self.session.filetype)
                            + " | " + self.mode + " | " + str(self.session.selection))
        except curses.error:
            # End of screen reached
            pass

        self.text_win.clrtobot()
        self.text_win.refresh()

    def set_status(self, string):
        self.status_win.bkgd(' ', curses.color_pair(9))
        try:
            self.status_win.addstr(0, 0, string, curses.color_pair(9))
        except:
            pass
        self.status_win.clrtobot()
        self.status_win.refresh()

    def prompt(self, prompt_string='>'):
        self.status_win.clear()
        y, x = self.stdscr.getmaxyx()
        self.status_win.addstr(0, 0, prompt_string)
        self.status_win.refresh()
        l = len(prompt_string)
        text_box_win = curses.newwin(1, x - l, y - 1, l)
        text_box_win.bkgd(' ', curses.color_pair(9))
        text_box = Textbox(text_box_win)
        text_box.edit()
        return text_box.gather()[:-1]


def move_n_wrapped_lines_up(text, wrap, start, n):
    import math
    position = text.rfind('\n', 0, start)
    if position == -1:
        return 0
    while 1:
        next = text.rfind('\n', 0, position - 1)
        if next == -1:
            return 0
        n -= math.ceil((position - next) / wrap)
        if n <= 0:
            return position + 1
        position = next

ui = UserInterface()
curses.wrapper(ui.main)
